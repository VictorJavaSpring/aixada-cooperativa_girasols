<?php

require(__ROOT__ . 'php/external/spreadsheet-reader/php-excel-reader/excel_reader2.php');
require(__ROOT__ . 'php/external/spreadsheet-reader/SpreadsheetReader.php');


ob_start(); // Probably only needed for FirePHP(no longer used)

  /** 
   * @package Aixada
   */ 

require_once(__ROOT__ . 'php/lib/exceptions.php');
require_once(__ROOT__ . 'local_config/config.php');
require_once(__ROOT__ . 'php/inc/database.php');
require_once(__ROOT__ . 'php/lib/data_table.php');
require_once(__ROOT__ . 'php/utilities/general.php');
require_once(__ROOT__ . 'php/lib/table_with_ref.php');





/**
 * 
 * Abstract class to handle different file formats for import and export files. Each subclass
 * has to overwrite this abstract class for the specific file format in question.
 *
 * @package Aixada
 */
class abstract_import_manager {
  
	
	/**
	 * Destination table in the database for the import data
	 * @var string
	 */
	protected $_db_table = null;
	
	/**
	 * 
	 * Data table that holds the import data
	 * @var data_table
	 */
	protected $_import_data_table = null;
	
	/**
	 * The list of fields that are available for importing as speciied in config.php for each table. import_fields 
	 * contains those fields that can be imported and that have been mapped in the original data file.
	 * @var array 
	 */
	protected $_import_fields = array(); 	
	
	/**
	 * The list of fields that are available for uptade as speciied in
     * config.php for each table. import_fields4update contains those fields
	 * that can be imported and that have been mapped in the original data file.
	 * @var array 
	 */
	protected $_import_fields4update = array();
	
	
	/**
	 * Mapping of data columns to db-fields used for insert and retrieve all
     * rows of the data_table column against which the db entries are matched.
	 * @var hash
	 */
	protected $_col_map = null;
	
	
	/**
	 * Mapping of data columns to db-fields used for update
	 * @var hash
	 */
	protected $_col_map_update = null;

	
	/**
	 * 
	 * Every subclass has to define the field in the database whose entries are used to match up
	 * the incomeing data rows. This is overwritten by the sub class. 
	 * @var string
	 */
	protected $_db_match_field = '';
	
	
	/**
	 * 
	 * Shortcut to the matching values of the original data table. 
	 * The match_col can be set once the data table and the db_match_field are known. 
	 * @var array
	 */
	protected $_match_col = array();
	
			
	/**
	 * Stores the index to the data table column that contains the values of the db match values. s 
	 * @var int
	 */
	protected $_match_col_index = null; 
	
	
	/**
	 * 
	 * Entries get attached to each insert sql query 
	 * @var unknown_type
	 */
	protected $_db_insert_row_prefix = array(); 
	

	/**
	 * 
	 * Entries get attached to each update row query
	 * @var unknown_type
	 */
	protected $_db_update_row_prefix = array(); 
	
	
	/**
	 * 
	 * Foreign keys info for the destination table generated by @foreign_key_manager
	 * @var array
	 */
	protected $_foreign_keys = null; 

	
	
	
	/**
	 * 
	 * Abstract import manager class. Expects the name of the destination table in the database, the source data_table and 
	 * a map. 
	 * @param string $destination_table name of destination database table 
	 * @param data_table $data_table two dimensional array holding the parsed source data
	 * @param array $map Establishes the mapping of the data table columns to the database table columns. Format 
	 * should be array('db_table_field_name'=> data_col_index, ... )
	 */
    public function __construct($destination_table, $data_table, $map)
    {


    	//get the import rights for the db table and fields
		$import_rights = configuration_vars::get_instance()->allow_import_for; 

    	//check if destination table exists in allowed tables
    	if (array_key_exists($destination_table, $import_rights)){
    		$this->_db_table = $destination_table; 
    	} else {
    		throw new Exception("Import error: can't find table '{$destination_table}' in the list of allowed import destinations. Check your config.php file.");      	
    		exit;
    	}

  	
        if ($data_table->count() == 0){
    		throw new Exception ("Import error: the data table is empty. Nothing to import!!");
    		exit; 
    	} else {
    		$this->_import_data_table = $data_table; 
    	}
    	
    	// Set maps
        if ($map != null && count($map) == 2 && 
                    isset($map['map_insert']) && 
                    isset($map['map_update'])) { // use dual map
            $this->_col_map = $map['map_insert'];
            $this->_col_map_update = $map['map_update'];
        } else { // use single map
            $this->_col_map = $map;
            $this->_col_map_update = $map;
        }
    	
    	//check which db table fields are available for importing and which ones are specified in the map. 
    	foreach ($import_rights[$this->_db_table] as $field => $value) {
    		if ($value == 'allow'){
    			if (isset($this->_col_map[$field])){
	    			array_push($this->_import_fields, $field);
    			}
    			if (isset($this->_col_map_update[$field])){
	    			array_push($this->_import_fields4update, $field);
    			}
    		}
    	}
    	
    	//check if db_match_field is in map
    	if (!isset($this->_col_map[$this->_db_match_field])){
    		throw new Exception("Import error: required match field '{$this->_db_match_field}' not found. You are either trying to import the wrong data for this table or have not associated the right column in the table preview!");
    		exit; 
    		
    	}
    
		if (count($this->_import_fields) == 0){
			throw new Exception("Import error: can't find any allowed fields for importing into table '{$destination_table}'. Check your config.php!  ");	
			exit; 
		}
		
		
		//the index of the column for matching table with db values
		$this->_match_col_index = $this->_col_map[$this->_db_match_field];
		
		//retrieves all rows of the data_table column against which the db entries are matched 
		$this->_match_col = $this->_import_data_table->get_col_as_array($this->_match_col_index);
		
		//get foreign key contraints of the destination table
    	$fkm = new foreign_key_manager($this->_db_table);
    	$this->_build_foreign_key_cache($fkm->get_keys());
    	
    	
        	   
    } 
    
    
    
  	/**
     * Function to be overwritten by each subclass.  
     * Should query the corresponding database table and return an 
     * array containing the ids of the existing rows.  
     * Returns array() 
     */
    protected function match_db_entries(){}
        
    
	/**
	 * 
	 * Executes the sequence of the import: 
	 * 		1: get existing rows for updating, 
	 * 		2: get new rows for insert, 
	 * 		3: construct rows and execute sql in each case
	 * @param boolean $append_new control insert behavior of new data rows
     * @param boolean $keep_match_field Set to true to keep db_match_field into
     *        insert staments (and rows without it are ignored) If $append_new
     *        is false $keep_match_field is ignored.
     * @return integer Number of rows imported.
	 */
    public function import($append_new=false, $keep_match_field = false){
    	
    	//format array('db_id'=>'custom_ref', ...)
    	$update_ids = $this->match_db_entries();

    	//data table rows that do not match existing rows in the database
    	//either because the ref does not exist or they are left empty (and hence cannot be matched)
    	$insert_rows = $this->_get_new_rows($update_ids);
    	
    	
    	$imported_rows_count = 0;
    	if (count($update_ids) > 0){
	    	//should be unique values
			$dup = $this->_check_duplicates($update_ids);
			if (count($dup) > 0){
				throw new Exception ("Import error: unique reference required but empty/duplicate key found in table column '{$this->_db_match_field}': " . implode(",",$dup));
				exit; 
			}
	    		
    		$imported_rows_count += $this->update_rows($update_ids);
    	}
    	
    	if ($append_new && count($insert_rows)){
    		$imported_rows_count +=
                            $this->insert_rows($insert_rows, $keep_match_field);
    	}
        return $imported_rows_count;
    }
    
   

    /**
     * 
     * Constructs update rows for already existing entries in the corresponding database table. 
     * @param array $update_ids of the format array('id'=>'custom ref value',...)
     * @return integer Number of rows updated.
     */
    protected function update_rows($update_ids){

    	$db = DBWrap::get_instance();

    	if (count($this->_import_fields4update) == 0) {
    		return; 
    	}
    	
    	$imported_rows_count = 0;
    	foreach($update_ids as $id => $match_id){
    		
    		//retrieve row from import data table
    		$row = $this->_import_data_table->search_row($this->_match_col_index, $match_id);
    		
    		//real db id to the row; required for the database wrapper update function
    		$db_update_row = array("table"=>$this->_db_table,"id"=>$id);

    		//add any additional entries, set in the subclass
    		array_merge($db_update_row, $this->_db_update_row_prefix);
    		
    		//take fields to be imported
    		foreach($this->_import_fields4update as $db_field){
    			//lookup its corresponding column in the import data table 	
    			$col_index = $this->_col_map_update[$db_field];
    			
    			//value to be imported
    			$import_value = $row[$col_index]; 
    			
    			//if field uses foreign key but insert value does not exist, leave default value
    			if (!$this->_foreign_key_exists($db_field, $import_value)){
    				continue; 
    			}
    			
    			//add it to the import_row	
				$db_update_row[$db_field] = $row[$col_index];	
			}

			
			//do sqlupdate row
			try {
                if ($db->Update($db_update_row)) {
                    $imported_rows_count++;
                }
			}  catch(Exception $e) {
    			header('HTTP/1.0 401 ' . $e->getMessage());
    			die ($e->getMessage());
			} 
    		
    		
    	} 
        return $imported_rows_count;
    }
    
    

    /**
     * 
     * Constructs array of db field => value pairs that can is passed to the dbWrapper-Insert function
     * @param array $insert_ids array of custom ref values that identify the rows to be inserted in the data table
     * @param boolean $keep_match_field Set to true to keep db_match_field into
     *        insert staments (and rows without it are ignored)
     * @return integer Number of rows inserted.
     */
	protected function insert_rows($insert_ids, $keep_match_field = false){
    	$db = DBWrap::get_instance();
    	
    	$imported_rows_count = 0;
    	foreach($insert_ids as $id => $index){	
    		//retrieve row from import data table could have an external id or not!!
    		$row = $this->_import_data_table->get_row($index);
    		    		
    		//set the db import table
    		$db_insert_row =  array("table"=>$this->_db_table);
    		
    		//add prefix stuff
    		$db_insert_row = array_merge($db_insert_row, $this->_db_insert_row_prefix);
    		    		
    		//take fields to be imported
    		foreach($this->_import_fields as $db_field){
    			//lookup its corresponding column in the import data table 	
    			$col_index = $this->_col_map[$db_field];
    			
    			//value to be imported
    			$import_value = $row[$col_index]; 
    			
    			//if field uses foreign key but insert value does not exist, leave default value
    			if (!$this->_foreign_key_exists($db_field, $import_value)){
    				continue; 
    			}
    			
    			//for aixada_products, the required custom_product_ref fields is unique with provider_id 
    			//because this field is empty when importing new products, we need to set the custom_product_ref to null
    			//i.e. leave it out of the sql insert string. Same would happen for nif of providers, although this has not a unique constraint
    			if ($db_field == $this->_db_match_field){
                    if ($keep_match_field) { // otherwise db_match_field (set by subclasses) are ignored.
                        if ($row[$col_index] == '') { // So row are ignored.
                            $db_insert_row = null;
                            break;
                        }
                        $db_insert_row[$db_field] = $row[$col_index];
                    } 
    			} else {
    				//add it to the import_row	
					$db_insert_row[$db_field] = $row[$col_index];	
    			}
			}

            if ($db_insert_row != null) {
                //do sql
                try {
                    if ($db->Insert($db_insert_row)) {
                        $imported_rows_count++;
                    }
                }  catch(Exception $e) {
                    header('HTTP/1.0 401 ' . $e->getMessage());
                    die ($e->getMessage());
				}
			} 
    		
    		
    	}  
  		return $imported_rows_count;
    }
    
    
    /**
     * 
     * Retrieves for each import table field with foreign key constraints the allowed
     * values. Maybe this could be recycled from table_with_ref??!
     * @param array $key_array The existing foreign keys on the destination import table
     */
    private function _build_foreign_key_cache($key_array){
    	$db = DBWrap::get_instance();
    	
    	$this->_foreign_keys = array();
    	foreach ($key_array as $db_field=>$refs){
    		if (isset($refs) && $refs && count($refs) > 1){
	    		$sql = "select ". $refs[1]." from " . $refs[0];
	    		$rs =  $db->Execute($sql);
	    		$ids = array();
    			while ($row = $rs->fetch_array()){
	    			  array_push($ids, $row[0]); 
	    		}
	    		$this->_foreign_keys[$db_field] = $ids; 
	    		
	    		$db->free_next_results(); 
    		}		
    		
    	}
    }
    
    
    /**
     * 
     * Checks wether a given import_value exists in the referenced table
     * @param string $table_field
     * @param mixed $import_value
     */
    private function _foreign_key_exists($table_field, $import_value){
    	$allow_import = false; 
    
    	//if $table_field does not have foreign key, allow import of whatever value
    	if (!array_key_exists($table_field, $this->_foreign_keys)){
    		$allow_import = true; 
    	} else {
	    	//if it is foreign key, then check if import value already exists. 
	    	$allow_import = in_array($import_value, $this->_foreign_keys[$table_field]);
    	}  

    	return $allow_import; 
    }
    
    
    /**
     * 
     * Utility function that checks if the matching column of the datatable contains duplicated entries. 
     * @param array $in_array array with unique values
     * @return array with duplicated values 
     */
    private function _check_duplicates($in_array){
   		//check for duplicate values in array
		$idcount = array_count_values($this->_match_col);
   		
		$duplicates = array();
		foreach($idcount as $value => $count ){
		    if( $count > 1 && $value != ''){     //don't count empty cells as duplicates since they could be used for inserting
		        array_push($duplicates, $value );
		    }
		}
		
		return $duplicates; 
    }
    
    
    /**
     * 
     * Retrieves the row index from the import data table that do not match any entries on the matching column.
     * If allow_update is set to true, then these entries will be added to the db. 
     * @param array $update_ids
     */
    private function _get_new_rows($update_ids){
    	$nr = $this->_import_data_table->get_nrows();
    	$insert_rows = array();
    	$i = ($this->_import_data_table->has_header())? 1:0; 
    	
    	for ($i; $i<$nr; $i++){
    		$row = $this->_import_data_table->get_row($i);	
    		//if the match_col value of the current does not exist, save this row for inserting
    		if (!in_array($row[$this->_match_col_index], $update_ids)){
    			array_push($insert_rows, $i);		
    		}
    	}
    	return $insert_rows; 
    }
    
    
    /**
     *
     * utility to make a list of match_col values.
     * @return string
     */
    protected function get_match_col_values() {
        $db = DBWrap::get_instance();
        $sql = '';
        foreach($this->_match_col as $val){
            if ($val != ''){
                $sql .= "'".$db->escape_string($val)."',";
            }
        }
        return rtrim($sql, ",");
    }

    /**
     * 
     * utility wrapper for parsing different uploaded files and returning a 2d array (data_table) with the values
     * @param string $path2File the full path to the file 
     * @param string $from_char_encoding Character encoding used by the file 
     *      (data are transformed to UTF-8), default is use the value 
     *      from config.php. Set to '' to ignore transformation.
     */
    public static function parse_file($path2File, $db_table='',
                                                    $from_char_encoding='$cfg'){
        $cfg = configuration_vars::get_instance();
        if ($from_char_encoding == '$cfg') {
            if (isset($cfg->import_from_char_encoding)) {
                $from_char_encoding = $cfg->import_from_char_encoding;
            }
        }
        
    	$rowc = 0;
  		$_data_table = array(); 
  		$_header = false; 		

  		$extension = substr($path2File, -4);

  	 	if ($extension == '.xml') {

  	 		$xml = simplexml_load_file($path2File);

			foreach ($xml->children() as $row) {
				$values = array();
				$fieldnames = array();
				foreach($row->children() as $elem){
					$values[] = (string)$elem;
					$fieldnames[] = $elem->getName(); 
				}
				abstract_import_manager::encode_utf8($values, $from_char_encoding);
				$_data_table[$rowc++] = $values; 
			}
			array_unshift($_data_table, $fieldnames);
			$_header=true; 
			
  		} else if (in_array($extension, array('.csv', '.tsv', '.txt', '.xlsx','.ods', '.xls'))) {
	 		$Reader = new SpreadsheetReader($path2File);
			foreach ($Reader as $Row){    
			  	abstract_import_manager::encode_utf8($Row, $from_char_encoding);
			  	$_data_table[$rowc++] = $Row; 
	
			}	

			//do some heuristics to detect if the first row contains column names. 
			$tmph = $_data_table[0];
			$hcount = 0; 
			
			//check empty cells
			foreach($tmph as $cell=>$value){
				if (is_string($value) && $value != '' && strlen($value)>1 && !is_numeric($value)){
					$hcount++;
				}
			}
			$_header = ($hcount == count($tmph))? true:false; 
  		}
							
		return new data_table($_data_table, $_header, $db_table);
    }
    
    /**
     * Transforms character encoding used by the array elements to UTF-8
     *
     * @param array $array Array to transform (argument by reference)
     * @param string $from_char_encoding Character encoding used by $array 
     *      elements, varue '' is ignored.
     */
    public static function encode_utf8(&$array, $from_char_encoding) {
        if ($from_char_encoding != '') {
            array_walk(
                $array, 
                function(&$string, $index, $char_encoding) {
                    $string = mb_convert_encoding(
                                      $string, 'UTF-8', $char_encoding);
                },
                $from_char_encoding
            );
        }
    }

} //end class abstract_import_manager






?>
